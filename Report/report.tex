\documentclass[a4paper, twoside, 11pt]{article}
\usepackage[margin=1.5cm]{geometry}
\usepackage[]{xcolor}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}
\usepackage{amsmath}

\usepackage{hyperref}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% define the title
\author{L. ~Towell,\\ Student No: 201383538}

%defines the title
\title{Assignment 1\break Brute Force Attack Estimation}

\begin{document}
	%generate the title
	\maketitle

\maketitle
\begin{center}
Code repository: \href{https://github.com/luketowell/COMP522-Assignment2}{COMP522-Assignment 2}
\end{center}

\section{Comparison of methods for message authentication}
\subsection{Hash-functions}
Hash functions are used in order to attempt to ensure to both the sender and the receiver that a message is authentic and has not been manipulated or interfered with in any way. Hash functions are typically used when a secret is not shared between the sender and the receiver. 
\\
The process of using a hash function is the following:\\
- An unencrypted message is sent from the sender to the receiver with a tag (hash) which has been generated by the sender.\\
- The receiver then received the message and the tag and in order to establish if the message has been tampered with they generate their own hash using the message from the sender.\\
- Once the receiver has generated their own hash they then compare the hash they generated to the hash they received as the tag. If the hash generated by the receiver doesn't match the tag hash then the message has been tampered with and the contents cant be trusted however if the hash and tag hash do match then the message hasnt been manipulated and can be trusted to be original.\\
\\
Hash functions are typically referred to as one way hashes. This is because it is easy to generate a hash using a message however it is very difficult to generate the message from the hash. The tag hash that is generated using a hash function algorithm e.g. the SHA1 typically produces a fixed length hash which is not dependent on the size of the message being sent.\\
\\
\textit{Appendix A} is an example of the SHA1 hash function which takes a string input and digests the input using the SHA1 algorithm to produce a byte array hash. 
\\
input = \\
output = \\
\\
The advantage of hash functions are that they are very simple to compute and are an effective way of telling if a message is genuine or if it has been manipulated.\\
\\
The disadvantage of Hash functions are that since the message is unencrypted, the content of the message is not secure so anyone can read the original message and as long as they dont change the hash then the hash will still match the original message. Hash functions also do not satisfy the weak and strong collision policys so it is possible you could generate a duplicate hash. A further issue with the SHA1 algorithm has been identified that it has a mathematical weakness which makes the outputs of the algorithm vulnerable to decryption.

\subsection{RSA + SHA1 method}
combination of the hashing mechanism SHA1 with the RSA algorithm. How does it work, what does it do. \textit {Appendix B and C}.
\textit { Appendix A } is used in order to provide added security and allows the user to ensure that the data has come from the correct person and hasnt been interfered with.
\subsection{DSA method}
DSA  \textit{Appendix D} How does it work, what does it do, why does it do that and so on.
\subsection{HMAC-SHA256 method}


\section{Diffie-Hellman with 4 parties}
\subsection{Design for the Diffie-Hellman Protocol}
Following the principles of the Diffie Hellman Protocol means that in order
to read the messages that are being transmitted every party needs to know the
public key of all of the other members in the network in order to generate a shared secret key.

The process is largely the same when more parties are added however because more parties have been added it means that more keys need to be generated and shared. Each party starts the process by using the shared prime number ($q$) and the shared primitive root ($\alpha$ of $q$).

Each key then generates their public keys using an random integer that they have generated. \\
\\
$Y_A = \alpha^{X_A}$ mod q \\
$Y_B = \alpha^{X_B}$ mod q \\
$Y_C = \alpha^{X_C}$ mod q \\
$Y_D = \alpha^{X_D}$ mod q \\

The above keys are then shared among all members of the network and then
then the following calculations are performed in order to calculate the shared secret Keys\\
\\
A calculates K = $(Y_{BCD})^{X_A}$ mod q \\
B calculates K = $(Y_{ACD})^{X_B}$ mod q \\
C calculates K = $(Y_{ABD})^{X_C}$ mod q \\
D calculates K = $(Y_{ABC})^{X_D}$ mod q \\


\textit{Figure 1.} is an example of the stages that each member of the network goes through in order to finally reach a shared secret key. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{Images/exchangeDiagram.png}
  \caption{Diagram of how keys are passed between members of network.}
\end{figure}
\subsection{Implementation of the Protocol with 4 Parties}
As discussed above in section 2.1 and can be seen from the code in \textit{Appendix D. } I have had to exchange all of the keys amongst each of the members in the network. I have done this through multiple iterations (phases) of the network in order
for everyone within the network to have all of the keys needed to successfully generate a shared secret key for decoding messages that are sent. 
\textit{figure 1.} shows the iteration cycle of how keys are exchanged over multiple iterations.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{Images/KeyIteration.png}
  \caption{Diagram of how keys are passed between members of network.}
  \setlength{\belowcaptionskip}{0pt}
\end{figure}


\textit{Table 1.} below details how the keys are gathered within the program. In iteration 0 the only keys that each
members have are their own however as we iterate around the network the keys are gathered until every member
has every other members public keys. Once every member has all of the other members public keys they are able to calculate the shared secret for the decoding of all messages. This is displayed in the code output via printing the secrets generated by each individual member and then comparing the keys. If the keys do not match then the program with throw an error however if all keys match the output should be the same as \textit{Appendix E.}

\begin{center}
	\begin{tabular}{ |c|l|l|l|l| } 
	 \hline
	 \multicolumn{1}{|c|}{}& \multicolumn {4}{|c|}{Public Keys held by network members} \\
	 \hline
   N & Alice & Bob & Carol & David \\
   \hline
   0 & A & B & C & D \\
   1 & AD & BA & CB & DC \\
   2 & ADC & BAD & CBA & DCB \\
   3 & ADCB & BADC & CBAD & DCBA \\
	 \hline
	\end{tabular}
\end{center}

\newpage
\section*{Appendices}
\appendix
\section{RSA Message Digestor}
\textbf{Note:} This small digestor is used within the example for RSA Encryption with SHA-1 Hashing (\textit{Appendix B}).
\lstinputlisting{../RSAEncryptionSHA1/src/MessageDigestor.java}
\newpage
\section{Diffie Hellman 4 Party Key Exchange}
\lstinputlisting{../Diffie_Hellman/src/DHKeyAgreement4.java}
\newpage
\section{Diffie Hellman 4 Party Output}
\textbf{Note:} If you would like to print the keys out in order to visually compare them yourself you can change this with the boolean flag in the code base. Change the variable \textit{showKeys} to false and then compile and run the program again. \\
\\
These Instructions assume you are compiling from the directory that the code file is in.\\
\textbf{Compile:}javac ./DHKeyAgreement4.java \\
\textbf{Run:}java DHKeyAgreement4
\\
\\
\textbf{Output:}
\lstinputlisting{./Files/DHKeyAgreement4_output.txt}

\end{document}