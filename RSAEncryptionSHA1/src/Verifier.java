import javax.crypto.Cipher;

public class Verifier {
    public static void main(String[] args) {

    }
    public static void verifyMessage (Message senderMessage) throws Exception{
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        byte[] verifierHashedInput = "".getBytes();

        //Decrypt the senders cipherText to get the hashedMessage using the publicKey
        cipher.init(Cipher.DECRYPT_MODE, senderMessage.getPubKey());
        byte[] plainText = cipher.doFinal(senderMessage.getHashedMessage());
        // Sender digest
        String senderDigest = Utils.toHex(plainText);

        //calculates own hashed message
        try{
            verifierHashedInput = MessageDigestor.messageDigest(senderMessage.getOriginalMessage());
        }catch (Exception e ){
            System.out.println("error: "+ e);
            System.exit(1);
        }

        String verifierDigest = Utils.toHex(verifierHashedInput);

        //compares if the hashed value generated by the verifier using the original message matches the sender hash which was decrypted using the public key.

        if( verifierDigest.equals(senderDigest)){
            System.out.println("digest values match");
            System.out.println("verifier hash: " + senderDigest);
            System.out.println("sender hash  : " + verifierDigest);
        } else {
            System.out.println("hashed values dont match this message is not trustworthy.");
            System.out.println("verifier hash: " + senderDigest);
            System.out.println("sender hash  : " + verifierDigest) ;
        }

    }
}
