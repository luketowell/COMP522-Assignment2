import javax.crypto.Cipher;
import java.security.Signature;

public class Verifier {
    public static void main(String[] args) {

    }
    public static void verifyMessage (Message senderMessage) throws Exception{
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        Signature dsa = Signature.getInstance("SHA256withDSA");
        byte[] verifierHashedInput = "".getBytes();

//        //Decrypt the senders cipherText to get the hashedMessage using the publicKey
//        cipher.init(Cipher.DECRYPT_MODE, senderMessage.getPubKey());
//        byte[] plainText = cipher.doFinal(senderMessage.getSignedHash());
//        // Sender digest
//        String senderDigest = Utils.toHex(plainText);

        //calculates own hashed message using the input that you have provided in the message being sent
        try{
            verifierHashedInput = MessageDigestor.messageDigest(senderMessage.getOriginalMessage());
        }catch (Exception e ){
            System.out.println("error: "+ e);
            System.exit(1);
        }

        //start verify password using the public key from the message
        dsa.initVerify(senderMessage.getPubKey());
        //run through the DSA using the hashed value that verifier has generated
        dsa.update(verifierHashedInput);

        //then verify the updated dsa against the key that was pashed with the sender.
        //If the values verify then they will return true otherwise they will return false.
        boolean verifies = dsa.verify(senderMessage.getSignedHash());

        //compares if the hashed value generated by the verifier using the original message matches the sender hash which was decrypted using the public key.

        if( verifies ){
            System.out.println("key values match");
        } else {
            System.out.println("hashed values dont match this message is not trustworthy.");
        }

    }
}
